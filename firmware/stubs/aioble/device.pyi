# aioble/device.pyi â€” MicroPython aioble device module type stubs
# MIT license; Copyright (c) 2021 Jim Mussared

from typing import Any, AsyncIterator, Optional
import asyncio

class DeviceDisconnectedError(Exception):
    """Raised by operations that are cancelled by device disconnection"""
    ...

class DeviceTimeout:
    """Context manager for operations with timeout and disconnection handling"""
    def __init__(self, connection: Optional['DeviceConnection'], timeout_ms: Optional[int]) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_traceback: Any) -> Any: ...

class Device:
    """Represents a BLE device (peripheral or central)"""
    addr_type: int
    addr: bytes
    _connection: Optional['DeviceConnection']

    def __init__(self, addr_type: int, addr: bytes | str) -> None: ...
    def __eq__(self, rhs: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def addr_hex(self) -> str: ...

    async def connect(
        self,
        timeout_ms: int = 10000,
        scan_duration_ms: Optional[int] = None,
        min_conn_interval_us: Optional[int] = None,
        max_conn_interval_us: Optional[int] = None,
    ) -> 'DeviceConnection': ...

class DeviceConnection:
    """Represents an active connection to a BLE device"""
    device: Device
    encrypted: bool
    authenticated: bool
    bonded: bool
    key_size: bool
    mtu: Optional[int]
    _conn_handle: Optional[int]
    _event: asyncio.ThreadSafeFlag
    _mtu_event: Optional[asyncio.ThreadSafeFlag]
    _discover: Any
    _characteristics: dict[int, Any]
    _task: Optional[asyncio.Task]
    _timeouts: list[DeviceTimeout]
    _pair_event: Optional[asyncio.ThreadSafeFlag]
    _l2cap_channel: Any

    # Class variable
    _connected: dict[int, 'DeviceConnection']

    def __init__(self, device: Device) -> None: ...
    async def device_task(self) -> None: ...
    def _run_task(self) -> None: ...
    async def disconnect(self, timeout_ms: int = 2000) -> None: ...
    async def disconnected(self, timeout_ms: Optional[int] = None, disconnect: bool = False) -> None: ...
    async def service(self, uuid: Any, timeout_ms: int = 2000) -> Any: ...
    def services(self, uuid: Optional[Any] = None, timeout_ms: int = 2000) -> AsyncIterator[Any]: ...
    async def pair(self, *args: Any, **kwargs: Any) -> None: ...
    def is_connected(self) -> bool: ...
    def timeout(self, timeout_ms: int) -> DeviceTimeout: ...
    async def exchange_mtu(self, mtu: Optional[int] = None, timeout_ms: int = 1000) -> int: ...
    async def l2cap_accept(self, psm: int, mtu: int, timeout_ms: Optional[int] = None) -> Any: ...
    async def l2cap_connect(self, psm: int, mtu: int, timeout_ms: int = 1000) -> Any: ...
    async def __aenter__(self) -> 'DeviceConnection': ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_traceback: Any) -> None: ...
